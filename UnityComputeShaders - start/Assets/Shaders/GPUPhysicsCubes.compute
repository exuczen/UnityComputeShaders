// Each #kernel tells which function to compile; you can have many kernels
#define CLEAR_GRID_THREAD_COUNT 8
#define RIGID_BODY_THREAD_COUNT 8
#define PARTICLE_THREAD_COUNT 8

#include "Utils/Math.cginc"

// Kernels
// Per Rigid Body	0
#pragma kernel GenerateParticleValues

// Per Grid Cell	1
#pragma kernel ClearGrid

// Per Particle		2
#pragma kernel PopulateGrid

// Per Particle		3
#pragma kernel CollisionDetectionWithGrid

// Per Rigid Body	4
#pragma kernel ComputeMomenta

// Per Rigid Body	5
#pragma kernel ComputePositionAndRotation

// Per Particle		6
#pragma kernel CollisionDetection

// Constants
// gridStartPosition				(float3) // lower left backward corner
// gridDimensions 					(int3)
// gridMax							(int) gridDimensions.x * gridDimensions.y * gridDimensions.z * 4
// particleDiameter 				(float)
// springCoefficient 				(float) (negative) (Equation 10)
// dampingCoefficient 				(float) (Equation 11)
// tangentialCoefficient 			(float) (Equation 12)
// particleCount					(int)number of particles
// activeCount						(int) active rigid bodies
struct RigidBody
{
    float3 position;
    float4 quaternion;
    float3 velocity;
    float3 angularVelocity;
    int particleIndex;
    int particleCount;
};

struct Particle
{
    float3 position;
    float3 velocity;
    float3 force;
    float3 localPosition;
    float3 offsetPosition;
};

struct Voxel
{
    int4 vox1;
    int4 vox2;
};

shared RWStructuredBuffer<RigidBody> rigidBodiesBuffer;
shared RWStructuredBuffer<Particle> particlesBuffer;
shared RWStructuredBuffer<Voxel> voxelGridBuffer;

int particleCount;
uint particlesPerRigidBody;
float deltaTime;
float particleMass;

//////////////////////////////
// Generate Particle Values //
//////////////////////////////
// Per Rigid Body
// Use rigidBody positions and 
// rigidBodyQuaternions to
// Generate particle positions
// and particle offsetPositions
// and particle velocities
//
//////////////////////////////
[numthreads(RIGID_BODY_THREAD_COUNT, 1, 1)]
void GenerateParticleValues(uint3 id : SV_DispatchThreadID)
{
    RigidBody body = rigidBodiesBuffer[id.x];
    int index = body.particleIndex;

    for (int i = 0; i < body.particleCount; i++)
    {
        Particle particle = particlesBuffer[index];
        particle.offsetPosition = quat_mul(body.quaternion, particle.localPosition);
        particle.position = body.position + particle.offsetPosition;
        particle.velocity = body.velocity + cross(body.angularVelocity, particle.offsetPosition);
        particlesBuffer[index] = particle;

        index++;
    }
}

//////////////////////
// Grid Generation //
/////////////////////
// Per Grid Cell
// Use particlePositions
// to populate the
// voxelGridBuffer
// Input
int3 gridDimensions;
float3 gridStartPosition;
int gridMax; // gridDimensions.x * gridDimensions.y * gridDimensions.z
float particleDiameter;

[numthreads(CLEAR_GRID_THREAD_COUNT, 1, 1)]
void ClearGrid(uint3 id : SV_DispatchThreadID)
{
    Voxel clearVoxel;
    clearVoxel.vox1 = -1;
    clearVoxel.vox2 = -1;
    voxelGridBuffer[id.x] = clearVoxel;
}

// Returns the grid index for particle p
int GetParticleGridIndex(int id)
{
    int3 gridLocation = (particlesBuffer[id].position - gridStartPosition) / particleDiameter;
    return gridLocation.x + (gridDimensions.x * gridLocation.y) + (gridDimensions.x * gridDimensions.y * gridLocation.z);
}

// Returns the grid location for particle p
int3 GetParticleGridLocation(int id)
{
    return (particlesBuffer[id].position - gridStartPosition) / particleDiameter;
}

// Converts a grid location to a grid index
int GetGridIndex(int x, int y, int z)
{
    return x + (gridDimensions.x * y) + (gridDimensions.x * gridDimensions.y * z);
}

int GetGridIndex(int3 loc)
{
    return loc.x + (gridDimensions.x * loc.y) + (gridDimensions.x * gridDimensions.y * loc.z);
}

[numthreads(PARTICLE_THREAD_COUNT, 1, 1)]
 void PopulateGrid(uint3 id : SV_DispatchThreadID)
{
    int3 xyz = GetParticleGridLocation(id.x);
    if (xyz.x >= 0 && xyz.x < gridDimensions.x &&
        xyz.y >= 0 && xyz.y < gridDimensions.y &&
        xyz.z >= 0 && xyz.z < gridDimensions.z)
    {
        int index = GetGridIndex(xyz);
        bool result = false;
        Voxel voxel = voxelGridBuffer[index];
        
        if (voxel.vox1.x < 0)
        {
            voxel.vox1.x = id.x;
        }
        else if (voxel.vox1.y < 0)
        {
            voxel.vox1.y = id.x;
        }
        else if (voxel.vox1.z < 0)
        {
            voxel.vox1.z = id.x;
        }
        else if (voxel.vox1.w < 0)
        {
            voxel.vox1.w = id.x;
        }
        else if (voxel.vox2.x < 0)
        {
            voxel.vox2.x = id.x;
        }
        else if (voxel.vox2.y < 0)
        {
            voxel.vox2.y = id.x;
        }
        else if (voxel.vox2.z < 0)
        {
            voxel.vox2.z = id.x;
        }
        else if (voxel.vox2.w < 0)
        {
            voxel.vox2.w = id.x;
        }
        voxelGridBuffer[index] = voxel;
    }
}

/////////////////////////
// Collision Detection //
/////////////////////////
// Per Particle
// Use particle positions, grid and velocity to compute Particle force
// Input
float springCoefficient;
float dampingCoefficient;
float tangentialCoefficient;

Particle GetGroundParticle(int i_id)
{
    Particle particleI = particlesBuffer[i_id];
    Particle particleJ = particleI;
    float radius = particleDiameter * 0.5;
    particleJ.position.y = min(-radius, particleI.position.y - radius);
    particleJ.velocity = 0;
    return particleJ;
}

float3 CollisionReaction(Particle pJ, Particle pI)
{
    float3 force = 0;
    float3 relativePosition = pJ.position - pI.position;
    float distance = length(relativePosition);
    if (distance < particleDiameter)
    {
        float3 normal = relativePosition / distance;
        
        float3 repulsiveForce = -springCoefficient * (particleDiameter - distance) * normal;
        
        float3 relativeVelocity = pJ.velocity - pI.velocity;
        float3 dampingForce = dampingCoefficient * relativeVelocity;
        
        float3 tangentialVelocity = relativeVelocity - dot(relativeVelocity, normal) * normal;
        float3 tangentialForce = tangentialCoefficient * tangentialVelocity;
        
        force = repulsiveForce + dampingForce + tangentialForce;
    }
    return force;
}

float3 CollisionReaction(int j_id, int i_id)
{
    return CollisionReaction(particlesBuffer[j_id], particlesBuffer[i_id]);
}

// checks cell x,y,z for collision with i, calls CollisionReaction if so
float3 ForceFromGridCell(int i, int x, int y, int z)
{
    float3 force = 0;
    
    if (x >= 0 && y >= 0 && z >= 0 && x < gridDimensions.x && y < gridDimensions.y && z < gridDimensions.z)
    {
        int index = GetGridIndex(x, y, z);
        if (index >= 0 && index < gridMax)
        {
            Voxel voxel = voxelGridBuffer[index];
            uint i_bodyIndex = i / particlesPerRigidBody;
            
            for (int j = 0; j < 4; j++)
            {
                int j_vox1 = voxel.vox1[j];
                if (j_vox1 >= 0 && j_vox1 != i && (j_vox1 / particlesPerRigidBody) != i_bodyIndex)
                {
                    force += CollisionReaction(j_vox1, i);
                }
                int j_vox2 = voxel.vox2[j];
                if (j_vox2 >= 0 && j_vox2 != i && (j_vox2 / particlesPerRigidBody) != i_bodyIndex)
                {
                    force += CollisionReaction(j_vox2, i);
                }
            }
        }
    }
    return force;
}

float gravityCoefficient;
[numthreads(PARTICLE_THREAD_COUNT, 1, 1)]
void CollisionDetectionWithGrid(uint3 id : SV_DispatchThreadID)
{
    float3 force = CollisionReaction(GetGroundParticle(id.x), particlesBuffer[id.x]);
    
    int3 loc = GetParticleGridLocation(id.x);
    
    for (int x = loc.x - 1; x <= loc.x + 1; x++)
    {
        for (int y = loc.y - 1; y <= loc.y + 1; y++)
        {
            for (int z = loc.z - 1; z <= loc.z + 1; z++)
            {
                force += ForceFromGridCell(id.x, x, y, z);
            }
        }
    }
    particlesBuffer[id.x].force = force;
}

[numthreads(PARTICLE_THREAD_COUNT, 1, 1)]
void CollisionDetection(uint3 id : SV_DispatchThreadID)
{
    float3 force = CollisionReaction(GetGroundParticle(id.x), particlesBuffer[id.x]);
    
    int bodyParticleIndex = particlesPerRigidBody * (int)(id.x / particlesPerRigidBody);
    
    for (int j = 0; j < bodyParticleIndex; j++)
    {
        force += CollisionReaction(j, id.x);
    }
    for (j = bodyParticleIndex + particlesPerRigidBody; j < particleCount; j++)
    {
        force += CollisionReaction(j, id.x);
    }
    particlesBuffer[id.x].force = force;
}

////////////////////////////
// Computation Of Momenta //
////////////////////////////
// Per RigidBdy
// Use particleForces to compute the force and angular force on the rigid body
float frictionCoefficient;
float angularFrictionCoefficient;
float angularForceScalar;
float linearForceScalar;
int activeCount;

[numthreads(RIGID_BODY_THREAD_COUNT, 1, 1)]
void ComputeMomenta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)activeCount)
    {
        float3 relativePosition = float3(0, 0, 0);
        float3 linearForce = float3(0, 0, 0);
        float3 angularForce = float3(0, 0, 0);

        RigidBody body = rigidBodiesBuffer[id.x];

        for (int i = 0; i < body.particleCount; i++)
        {
            Particle particle = particlesBuffer[body.particleIndex + i];
            relativePosition = particle.offsetPosition;
            linearForce += particle.force;
            angularForce += cross(relativePosition, particle.force);
        }

        float threshold = 1.0 / pow(10.0, 6);

        float cubeMass = particleMass * body.particleCount;
        body.velocity /= 1.0 + deltaTime * frictionCoefficient;
        body.velocity += linearForceScalar * deltaTime * linearForce / cubeMass;
        body.velocity.y -= gravityCoefficient * deltaTime;
        if (length(body.velocity) < threshold)
        {
            body.velocity = 0;
        }

		// new rotation
        body.angularVelocity /= 1.0 + deltaTime * angularFrictionCoefficient;
        body.angularVelocity += angularForceScalar * deltaTime * angularForce; // probably wrong  
        if (length(body.angularVelocity) < threshold)
        {
            body.angularVelocity = 0;
        }

        rigidBodiesBuffer[id.x] = body;
    }
}

/////////////////////////////
// Computation Of Position //
/////////////////////////////
// Per RigidBody
// Use rigidBodyForce and rigidBodyTorque to compute the rigid body position and rotation.
[numthreads(RIGID_BODY_THREAD_COUNT, 1, 1)]
void ComputePositionAndRotation(uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)activeCount)
    {
        RigidBody body = rigidBodiesBuffer[id.x];
        body.position += body.velocity * deltaTime;

        float4 omega = float4(body.angularVelocity, 0);
        body.quaternion = normalize(body.quaternion + deltaTime * (0.5 * quat_concat(omega, body.quaternion)));

        rigidBodiesBuffer[id.x] = body;
    }
}

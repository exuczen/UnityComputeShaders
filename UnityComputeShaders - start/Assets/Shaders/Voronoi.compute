#define CIRCLE_THREADS int3(16, 1, 1) // max 1024
#define CIRCLE_THREADS_2D 1
#define CLEAR_THREADS int3(32, 32, 1)
#define USE_RANDOM_XORSHIFT 1

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DrawPoints
#pragma kernel DrawCircles
#pragma kernel DrawDiamonds
#pragma kernel DrawLine
#pragma kernel FillCircles
#pragma kernel ClearTextures
#pragma kernel InitParticles
#pragma kernel RandomParticles
#pragma kernel UpdateParticles

#include "Utils/Random.cginc"
#include "Utils/Geometry.cginc"
#include "Voronoi.hlsl"

uint PointsCapacity;
uint PointsCount;
uint PointsRowThreadsCount;
int Radius;
int RadiusSqr;
float4 ClearColor;
float Time;

#if CIRCLE_THREADS_2D
uint getParticleIndex(uint3 id)
{
    return id.y * PointsRowThreadsCount + id.x;
}
#else
uint getParticleIndex(uint3 id)
{
    return id.x;
}
#endif

int2 getParticlePosition(uint i)
{
    return particlesBuffer[i].position;
}

void respawnParticle(int i, float lifetimeMin, float lifetimeMax)
{
    Particle p = particlesBuffer[i];
    
    if (p.color.w > 0.5) // Clear particle's pixel
    {
        int xyIndex = p.position.y * TexResolution + p.position.x;
        int j = indexBuffer[xyIndex];

        outputTexture[p.position] = ClearColor;
        indexBuffer[j] = -1;
    }
#if USE_RANDOM_XORSHIFT
    rng_state = particlesBuffer[i].randomSeed;
    //p.position = (0.25 + random2_xorshift() * 0.5) * TexResolution;
    p.position = (int2)(random2_xorshift() * TexResolution);
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random_xorshift());
    p.color = float4(random3_xorshift(), 1.0);
    p.randomSeed = rng_state;
#else
    float seedValue = i + Time;
    float seedDelta = 0.33;
    p.position = (int2)(random2(seedValue) * TexResolution);
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random(seedValue += seedDelta));
    p.color = float4(random3(seedValue += seedDelta), 1.0);
    p.randomSeed = 0;
#endif
    p.filled = false;
    
    // Write particle's pixel
    {
        int xyIndex = p.position.y * TexResolution + p.position.x;
        int j = indexBuffer[xyIndex];
        
        if (j >= 0 && i != j)
        {
            uint jRandomSeed = particlesBuffer[j].randomSeed;
            particlesBuffer[j] = getClearParticle(jRandomSeed);
        }
        plotParticle(p, i);
    }
    particlesBuffer[i] = p;
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void InitParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    //particlesBuffer[i] = getClearParticle(wang_hash(i));
    particlesBuffer[i] = getClearParticle(lgc_hash(i));
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void RandomParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    respawnParticle(i, 0.0, 1.0);
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void DrawPoints(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    particlesBuffer[i].filled = false;
    
    plotParticle(i);
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void UpdateParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    if (Time > particlesBuffer[i].endTime)
    {
        respawnParticle(i, 0.1, 1.0);
    }
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void DrawCircles(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    int2 center = getParticlePosition(i);
    bool filled = particlesBuffer[i].filled;
    if (filled || center.x < 0)
    {
        return;
    }
    bool result = false;
    //result = result | drawJeskoCircle(center, Radius, i);
    result = result | drawMidpointCircle(center, Radius, i);
    //result = result | drawMidpoint2Circle(center, Radius, i);
    result = result | drawHornCircle(center, Radius, i);
    particlesBuffer[i].filled = !result;
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void DrawDiamonds(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    drawDiamond(getParticlePosition(id.x), Radius, id.x);
}

[numthreads(31, 31, 1)]
void FillCircles(uint3 id : SV_DispatchThreadID)
{
    int2 center = int2(15, 15);
    int2 ray = (int2)id.xy - center;
    uint2 xy = getParticlePosition(id.z) + ray;
    
    if (outputTexture[xy].w < 0.5 && dot(ray, ray) < RadiusSqr)
    {
        outputTexture[xy] = getXYGradientColor(ray.x, ray.y);
    }
}

[numthreads(1, 1, 1)]
void DrawLine(uint3 id : SV_DispatchThreadID)
{
    drawLine(outputTexture, getParticlePosition(0), getParticlePosition(1), 1);
}

[numthreads(CLEAR_THREADS.x, CLEAR_THREADS.y, CLEAR_THREADS.z)]
void ClearTextures(uint3 id : SV_DispatchThreadID)
{
    outputTexture[id.xy] = ClearColor;
    indexBuffer[id.y * TexResolution + id.x] = -2;
}

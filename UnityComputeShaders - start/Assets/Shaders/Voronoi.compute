#define CIRCLE_THREADS 8 // max 1024
#define CLEAR_THREADS 32
#define USE_RANDOM_XORSHIFT 1

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Points
#pragma kernel Circles
#pragma kernel Diamonds
#pragma kernel FillCircles
#pragma kernel ClearTextures
#pragma kernel Line
#pragma kernel RandomParticles
#pragma kernel Particles

#include "Utils/Random.cginc"
#include "Utils/Geometry.cginc"
#include "Voronoi.hlsl"

int TexResolution;
uint PointsCapacity;
uint PointsCount;
int Radius;
int RadiusSqr;
float4 ClearColor;
float Time;

int2 getParticlePosition(uint i)
{
    return particlesBuffer[i].position;
}

void respawnParticle(int i, float lifetimeMin, float lifetimeMax)
{
    Particle p = particlesBuffer[i];
    if (p.indexColor.w > 0.0) // Clear pixel colors
    {
        outputTexture[p.position] = ClearColor;
        indexTexture[p.position] = 0.0;
    }
#if USE_RANDOM_XORSHIFT
    rng_state = particlesBuffer[i].randomSeed;
    p.position = (int2)(random2_xorshift() * TexResolution);
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random_xorshift());
    p.color = float4(random3_xorshift(), 1.0);
    p.randomSeed = rng_state;
#else
    float seedValue = i + Time;
    float seedDelta = 0.33;
    p.position = (int2)(random2(seedValue) * TexResolution);
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random(seedValue += seedDelta));
    p.color = float4(random3(seedValue += seedDelta), 1.0);
    p.randomSeed = 0;
#endif
    p.filled = false;
    
    // Write pixel colors
    {
        float4 indexColor = indexTexture[p.position];
        if (indexColor.w > 0.0)
        {
            int x = (int)(indexColor.x * 255) << 0;
            int y = (int)(indexColor.y * 255) << 8;
            int z = (int)(indexColor.z * 255) << 16;
            int j = x | y | z;
            if (i != j)
            {
                particlesBuffer[j].position = int2(-1, -1);
                particlesBuffer[j].endTime = 0.0;
                particlesBuffer[j].indexColor = 0.0;
            }
        }
        float x = (((i >> 0) & 0xff) + 0.5) / 255.0;
        float y = (((i >> 8) & 0xff) + 0.5) / 255.0;
        float z = (((i >> 16) & 0xff) + 0.5) / 255.0;
    
        p.indexColor = float4(x, y, z, 1.0);
        
        plotParticleColors(p);
    }
    particlesBuffer[i] = p;
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void RandomParticles(uint3 id : SV_DispatchThreadID)
{
    //particlesBuffer[id.x].randomSeed = wang_hash(id.x);
    particlesBuffer[id.x].randomSeed = lgc_hash(id.x);
    particlesBuffer[id.x].endTime = 0.0;
    particlesBuffer[id.x].filled = false;
    
    if (id.x < PointsCount)
    {
        respawnParticle(id.x, 0.0, 1.0);
    }
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Points(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    particlesBuffer[id.x].filled = false;
    plotParticleColors(id.x);
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Particles(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    if (Time > particlesBuffer[id.x].endTime)
    {
        respawnParticle(id.x, 0.1, 1.0);
    }
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Circles(uint3 id : SV_DispatchThreadID)
{
    int2 center = getParticlePosition(id.x);
    bool filled = particlesBuffer[id.x].filled;
    
    if (id.x >= PointsCount || filled || center.x < 0)
    {
        return;
    }
    bool result = false;
    //result = result | drawJeskoCircle(center, Radius, id.x);
    result = result | drawMidpointCircle(center, Radius, id.x);
    //result = result | drawMidpoint2Circle(center, Radius, id.x);
    result = result | drawHornCircle(center, Radius, id.x);
    particlesBuffer[id.x].filled = !result;
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Diamonds(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    drawDiamond(getParticlePosition(id.x), Radius, id.x);
}

[numthreads(31, 31, 1)]
void FillCircles(uint3 id : SV_DispatchThreadID)
{
    int2 center = int2(15, 15);
    int2 ray = (int2)id.xy - center;
    uint2 xy = getParticlePosition(id.z) + ray;
    
    if (outputTexture[xy].w == 0.0 && dot(ray, ray) < RadiusSqr)
    {
        outputTexture[xy] = getXYGradientColor(ray.x, ray.y);
    }
}

[numthreads(1, 1, 1)]
void Line(uint3 id : SV_DispatchThreadID)
{
    drawLine(outputTexture, getParticlePosition(0), getParticlePosition(1), 1);
}

[numthreads(CLEAR_THREADS, CLEAR_THREADS, 1)]
void ClearTextures(uint3 id : SV_DispatchThreadID)
{
    outputTexture[id.xy] = ClearColor;
    indexTexture[id.xy] = 0.0;
}

#define CIRCLE_THREADS int3(16, 1, 1) // max 1024
//#define CIRCLE_THREADS_2D
#define CLEAR_THREADS int3(32, 32, 1)
#define ANGULAR_PAIRS_STRIDE 33
#define REPLACE_PARTICLES

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DrawPoints
#pragma kernel DrawCircles
#pragma kernel DrawDiamonds
#pragma kernel DrawLine
#pragma kernel DrawPairLines
#pragma kernel FillCircles
#pragma kernel ClearTextures
#pragma kernel ClearPairs
#pragma kernel InitParticles
#pragma kernel RandomParticles
#pragma kernel UpdateParticles
#pragma kernel FindPairs

#include "Utils/Random.cginc"
#include "Utils/Geometry.cginc"
#include "Voronoi.hlsl"

uint PointsCapacity;
uint PointsCount;
uint PointsRowThreadsCount;
int Radius;
int RadiusSqr;
float LinesLerpValue;

#ifdef CIRCLE_THREADS_2D
uint getParticleIndex(uint3 id)
{
    return id.y * PointsRowThreadsCount + id.x;
}
#else
uint getParticleIndex(uint3 id)
{
    return id.x;
}
#endif

int2 getParticlePosition(uint i)
{
    return particlesBuffer[i].position;
}

void respawnParticle(int i, float lifetimeMin, float lifetimeMax)
{
    rng_state = particlesBuffer[i].randomSeed;
    
    //int2 xy = (0.25 + random2_xorshift() * 0.5) * TexResolution;
    int2 xy = (int2)(random2_xorshift() * TexResolution);
    int j = indexBuffer[xy.y * TexResolution + xy.x];
    if (j >= 0 && i != j)
    {
#ifdef REPLACE_PARTICLES
        particlesBuffer[j].endTime = 0.0;
        particlesBuffer[j].active = false;
#else
        return;
#endif
    }
    Particle p;
    p.position = xy;
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random_xorshift());
    p.color = float4(random3_xorshift(), 1.0);
    p.randomSeed = rng_state;
    p.active = true;
    
    plotParticle(p, i); // Write particle's pixel
    
    particlesBuffer[i] = p;
}

void setParticlesAngularPair(uint j, uint k)
{
    uint iMin = min(j, k);
    uint iMax = max(j, k);
    j = iMin;
    k = iMax;
    float2 posJ = getParticlePosition(j);
    float2 posK = getParticlePosition(k);
    float2 dr = posK - posJ;
    float angle = PI - atan2(dr.y, dr.x);
    uint angleDivisions = ANGULAR_PAIRS_STRIDE - 1;
    //uint angleSection = (int)(angle * angleDivisions / PI2 + 0.5f) % angleDivisions;
    uint angleSection = (int)(angle * angleDivisions / PI2);
    uint jOffset = j * (angleDivisions + 1);
    angularPairBuffer[jOffset] = j;
    angularPairBuffer[jOffset + 1 + angleSection] = k;
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void InitParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    //particlesBuffer[i] = getClearParticle(wang_hash(i));
    particlesBuffer[i] = getClearParticle(lgc_hash(i));
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void RandomParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    respawnParticle(i, 0.0, 1.0);
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void DrawPoints(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    tryPlotParticle(i);
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void UpdateParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    if (getParticlePosition(i).x < 0)
    {
        respawnParticle(i, 0.1, 1.0);
    }
}

[numthreads(CLEAR_THREADS.x, CLEAR_THREADS.y, CLEAR_THREADS.z)]
void FindPairs(uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;
    if (x < 1 | y < 1 | x > TexResolution - 3 | y > TexResolution - 3)
    {
        return;
    }
    int yOffset = y * TexResolution;
    int i = indexBuffer[yOffset + x - 1];
    int j = indexBuffer[yOffset + x];
    int k = indexBuffer[yOffset + x + 1];
    int l = indexBuffer[yOffset + x + 2];
    
    if (j >= 0 & k >= 0 & j != k & k != i & j != l)
    {
        setParticlesAngularPair(j, k);
    }
    i = indexBuffer[yOffset - TexResolution + x];
    j = indexBuffer[yOffset + x];
    k = indexBuffer[yOffset + TexResolution + x];
    l = indexBuffer[yOffset + TexResolution * 2 + x];
    
    if (j >= 0 & k >= 0 & j != k & k != i & j != l)
    {
        setParticlesAngularPair(j, k);
    }
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, ANGULAR_PAIRS_STRIDE)]
void DrawPairLines(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    //i = angularPairBuffer[i * ANGULAR_PAIRS_STRIDE];
    uint j = angularPairBuffer[i * ANGULAR_PAIRS_STRIDE + id.z];
    if (i != j)
    {
        drawLine(outputTexture, getParticlePosition(i), getParticlePosition(j), 1.0, LinesLerpValue);
    }
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, ANGULAR_PAIRS_STRIDE)]
void ClearPairs(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    uint j = i * ANGULAR_PAIRS_STRIDE + id.z;
    angularPairBuffer[j] = i;
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void DrawCircles(uint3 id : SV_DispatchThreadID)
{
    uint i = getParticleIndex(id);
    if (i >= PointsCount)
    {
        return;
    }
    // Unlike short-circuit evaluation of &&, ||, and ?: in C, HLSL expressions never short-circuit an evaluation
    // because they are vector operations. All sides of the expression are always evaluated.
    if (!particlesBuffer[i].active)
    {
        return;
    }
    int2 center = getParticlePosition(i);
    bool result = false;
    //result = result | drawJeskoCircle(center, Radius, i);
    result = result | drawMidpointCircle(center, Radius, i);
    //result = result | drawMidpoint2Circle(center, Radius, i);
    result = result | drawHornCircle(center, Radius, i);
    particlesBuffer[i].active = result;
}

[numthreads(CIRCLE_THREADS.x, CIRCLE_THREADS.y, CIRCLE_THREADS.z)]
void DrawDiamonds(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    drawDiamond(getParticlePosition(id.x), Radius, id.x);
}

[numthreads(31, 31, 1)]
void FillCircles(uint3 id : SV_DispatchThreadID)
{
    int2 center = int2(15, 15);
    int2 ray = (int2)id.xy - center;
    uint2 xy = getParticlePosition(id.z) + ray;
    
    if (outputTexture[xy].w < 0.5 && dot(ray, ray) < RadiusSqr)
    {
        outputTexture[xy] = getXYGradientColor(ray.x, ray.y);
    }
}

[numthreads(1, 1, 1)]
void DrawLine(uint3 id : SV_DispatchThreadID)
{
    drawLine(outputTexture, getParticlePosition(0), getParticlePosition(1), 1);
}

[numthreads(CLEAR_THREADS.x, CLEAR_THREADS.y, CLEAR_THREADS.z)]
void ClearTextures(uint3 id : SV_DispatchThreadID)
{
    outputTexture[id.xy] = ClearColor;
    indexBuffer[id.y * TexResolution + id.x] = -1;
}

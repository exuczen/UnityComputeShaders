#define CIRCLE_THREADS 1024
#define CLEAR_THREADS 32
#define USE_RANDOM_XORSHIFT

// Each #kernel tells which function to compile; you can have many kernels
//#pragma kernel Points
#pragma kernel Circles
#pragma kernel Diamonds
#pragma kernel FillCircles
#pragma kernel Clear
#pragma kernel Line
#pragma kernel RandomParticles
#pragma kernel Particles

#include "Utils/Random.cginc"
#include "Utils/Geometry.cginc"
#include "Voronoi.hlsl"

struct Particle
{
    int2 position;
    float endTime;
    uint randomSeed;
};

shared RWStructuredBuffer<Particle> particlesBuffer;

int TexResolution;
int PointsCount;
int Radius;
int RadiusSqr;
float4 ClearColor;
float4 CircleColor;
float Time;

int2 getParticlePosition(uint i)
{
    return particlesBuffer[i].position;
}

void respawnParticle(uint i)
{
#ifdef USE_RANDOM_XORSHIFT
    rng_state = particlesBuffer[i].randomSeed;
    particlesBuffer[i].position = (int2)(random2_xorshift() * TexResolution);
    particlesBuffer[i].endTime = Time + random_xorshift();
    particlesBuffer[i].randomSeed = rng_state;
#else
    float seedValue = i + Time;
    particlesBuffer[i].position = (int2)(random2(seedValue) * TexResolution);
    particlesBuffer[i].endTime = Time + random(seedValue);
#endif
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void RandomParticles(uint3 id : SV_DispatchThreadID)
{
    //particlesBuffer[id.x].randomSeed = wang_hash(id.x);
    particlesBuffer[id.x].randomSeed = lgc_hash(id.x);
    respawnParticle(id.x);
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Particles(uint3 id : SV_DispatchThreadID)
{
    if (Time > particlesBuffer[id.x].endTime)
    {
        respawnParticle(id.x);
    }
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Circles(uint3 id : SV_DispatchThreadID)
{
    //drawJeskoCircle(getParticlePosition(id.x), Radius, id.x);
    drawMidpointCircle(getParticlePosition(id.x), Radius, id.x);
    //drawMidpoint2Circle(getParticlePosition(id.x), Radius, id.x);
    drawHornCircle(getParticlePosition(id.x), Radius, id.x);
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Diamonds(uint3 id : SV_DispatchThreadID)
{
    drawDiamond(getParticlePosition(id.x), Radius, id.x);
}

[numthreads(31, 31, 1)]
void FillCircles(uint3 id : SV_DispatchThreadID)
{
    int2 center = int2(15, 15);
    int2 ray = (int2)id.xy - center;
    uint2 xy = getParticlePosition(id.z) + ray;
    
    if (output[xy].w == 0.0 && dot(ray, ray) < RadiusSqr)
    {
        output[xy] = getCirclePixel(ray.x, ray.y);
    }
}

[numthreads(1, 1, 1)]
void Line(uint3 id : SV_DispatchThreadID)
{
    drawLine(output, getParticlePosition(0), getParticlePosition(1), 1);
}

[numthreads(CLEAR_THREADS, CLEAR_THREADS, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    output[id.xy] = ClearColor;
}

#define CIRCLE_THREADS 8 // max 1024
#define CLEAR_THREADS 32
#define USE_RANDOM_XORSHIFT

// Each #kernel tells which function to compile; you can have many kernels
//#pragma kernel Points
#pragma kernel Circles
#pragma kernel Diamonds
#pragma kernel FillCircles
#pragma kernel ClearOutputTexture
#pragma kernel ClearIndexTexture
#pragma kernel Line
#pragma kernel RandomParticles
#pragma kernel Particles

#include "Utils/Random.cginc"
#include "Utils/Geometry.cginc"
#include "Voronoi.hlsl"

int TexResolution;
uint PointsCapacity;
uint PointsCount;
int Radius;
int RadiusSqr;
float4 ClearColor;
float Time;

int2 getParticlePosition(uint i)
{
    return particlesBuffer[i].position;
}

void respawnParticle(uint i, float lifetimeMin, float lifetimeMax)
{
    Particle p;
#ifdef USE_RANDOM_XORSHIFT
    rng_state = particlesBuffer[i].randomSeed;
    p.position = (int2)(random2_xorshift() * TexResolution);
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random_xorshift());
    p.color = float4(random3_xorshift(), 1.0);
    p.randomSeed = rng_state;
#else
    float seedValue = i + Time;
    float seedDelta = 0.33;
    p.position = (int2)(random2(seedValue) * TexResolution);
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random(seedValue += seedDelta));
    p.color = float4(random3(seedValue += seedDelta), 1.0);
    p.randomSeed = 0;
#endif
    particlesBuffer[i] = p;
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void RandomParticles(uint3 id : SV_DispatchThreadID)
{
    //particlesBuffer[id.x].randomSeed = wang_hash(id.x);
    particlesBuffer[id.x].randomSeed = lgc_hash(id.x);
    particlesBuffer[id.x].endTime = 0.0;
    
    if (id.x < PointsCount)
    {
        respawnParticle(id.x, 0.0, 1.0);
    }
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Particles(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    if (Time > particlesBuffer[id.x].endTime)
    {
        respawnParticle(id.x, 0.1, 1.0);
    }
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Circles(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    //drawJeskoCircle(getParticlePosition(id.x), Radius, id.x);
    drawMidpointCircle(getParticlePosition(id.x), Radius, id.x);
    //drawMidpoint2Circle(getParticlePosition(id.x), Radius, id.x);
    drawHornCircle(getParticlePosition(id.x), Radius, id.x);
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Diamonds(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    drawDiamond(getParticlePosition(id.x), Radius, id.x);
}

[numthreads(31, 31, 1)]
void FillCircles(uint3 id : SV_DispatchThreadID)
{
    int2 center = int2(15, 15);
    int2 ray = (int2)id.xy - center;
    uint2 xy = getParticlePosition(id.z) + ray;
    
    if (outputTexture[xy].w == 0.0 && dot(ray, ray) < RadiusSqr)
    {
        outputTexture[xy] = getCirclePixel(ray.x, ray.y);
    }
}

[numthreads(1, 1, 1)]
void Line(uint3 id : SV_DispatchThreadID)
{
    drawLine(outputTexture, getParticlePosition(0), getParticlePosition(1), 1);
}

[numthreads(CLEAR_THREADS, CLEAR_THREADS, 1)]
void ClearOutputTexture(uint3 id : SV_DispatchThreadID)
{
    outputTexture[id.xy] = ClearColor;
}

[numthreads(CLEAR_THREADS, CLEAR_THREADS, 1)]
void ClearIndexTexture(uint3 id : SV_DispatchThreadID)
{
    indexTexture[id.xy] = 0;
}

#define CIRCLE_THREADS 8 // max 1024
#define CLEAR_THREADS 32
#define USE_RANDOM_XORSHIFT 1

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Points
#pragma kernel Circles
#pragma kernel Diamonds
#pragma kernel FillCircles
#pragma kernel ClearTextures
#pragma kernel Line
#pragma kernel RandomParticles
#pragma kernel Particles

#include "Utils/Random.cginc"
#include "Utils/Geometry.cginc"
#include "Voronoi.hlsl"

uint PointsCapacity;
uint PointsCount;
int Radius;
int RadiusSqr;
float4 ClearColor;
float Time;

int2 getParticlePosition(uint i)
{
    return particlesBuffer[i].position;
}

void respawnParticle(int i, float lifetimeMin, float lifetimeMax)
{
    Particle p = particlesBuffer[i];
    
    if (p.color.w > 0.0) // Clear particle's pixel
    {
        int xyIndex = p.position.y * TexResolution + p.position.x;
        int j = indexBuffer[xyIndex];

        outputTexture[p.position] = ClearColor;
        indexBuffer[j] = -1;
    }
#if USE_RANDOM_XORSHIFT
    rng_state = particlesBuffer[i].randomSeed;
    p.position = (int2)(random2_xorshift() * TexResolution);
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random_xorshift());
    p.color = float4(random3_xorshift(), 1.0);
    p.randomSeed = rng_state;
#else
    float seedValue = i + Time;
    float seedDelta = 0.33;
    p.position = (int2)(random2(seedValue) * TexResolution);
    p.endTime = Time + lerp(lifetimeMin, lifetimeMax, random(seedValue += seedDelta));
    p.color = float4(random3(seedValue += seedDelta), 1.0);
    p.randomSeed = 0;
#endif
    p.filled = false;
    
    // Write particle's pixel
    {
        int xyIndex = p.position.y * TexResolution + p.position.x;
        int j = indexBuffer[xyIndex];
        
        if (j >= 0 && i != j)
        {
            uint jRandomSeed = particlesBuffer[j].randomSeed;
            particlesBuffer[j] = getClearParticle(jRandomSeed);
        }
        plotParticle(p, i);
    }
    particlesBuffer[i] = p;
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void RandomParticles(uint3 id : SV_DispatchThreadID)
{
    //particlesBuffer[id.x] = getClearParticle(wang_hash(id.x));
    particlesBuffer[id.x] = getClearParticle(lgc_hash(id.x));
    
    if (id.x < PointsCount)
    {
        respawnParticle(id.x, 0.0, 1.0);
    }
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Points(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    particlesBuffer[id.x].filled = false;
    
    plotParticle(id.x);
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Particles(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    if (Time > particlesBuffer[id.x].endTime)
    {
        respawnParticle(id.x, 0.1, 1.0);
    }
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Circles(uint3 id : SV_DispatchThreadID)
{
    int2 center = getParticlePosition(id.x);
    bool filled = particlesBuffer[id.x].filled;
    
    if (id.x >= PointsCount || filled || center.x < 0)
    {
        return;
    }
    bool result = false;
    //result = result | drawJeskoCircle(center, Radius, id.x);
    result = result | drawMidpointCircle(center, Radius, id.x);
    //result = result | drawMidpoint2Circle(center, Radius, id.x);
    result = result | drawHornCircle(center, Radius, id.x);
    particlesBuffer[id.x].filled = !result;
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Diamonds(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsCount)
    {
        return;
    }
    drawDiamond(getParticlePosition(id.x), Radius, id.x);
}

[numthreads(31, 31, 1)]
void FillCircles(uint3 id : SV_DispatchThreadID)
{
    int2 center = int2(15, 15);
    int2 ray = (int2)id.xy - center;
    uint2 xy = getParticlePosition(id.z) + ray;
    
    if (outputTexture[xy].w == 0.0 && dot(ray, ray) < RadiusSqr)
    {
        outputTexture[xy] = getXYGradientColor(ray.x, ray.y);
    }
}

[numthreads(1, 1, 1)]
void Line(uint3 id : SV_DispatchThreadID)
{
    drawLine(outputTexture, getParticlePosition(0), getParticlePosition(1), 1);
}

[numthreads(CLEAR_THREADS, CLEAR_THREADS, 1)]
void ClearTextures(uint3 id : SV_DispatchThreadID)
{
    outputTexture[id.xy] = ClearColor;
    indexBuffer[(int)id.y * TexResolution + (int)id.x] = -1;
}

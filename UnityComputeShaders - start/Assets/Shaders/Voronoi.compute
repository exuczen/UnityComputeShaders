#define CIRCLE_THREADS 1024
#define CLEAR_THREADS 32

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Points
#pragma kernel Circles
#pragma kernel Diamonds
#pragma kernel FillCircles
#pragma kernel Clear
#pragma kernel Line

#include "Utils/Random.cginc"
#include "Utils/Geometry.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
shared RWTexture2D<float4> Result;
shared RWStructuredBuffer<int2> PointsBuffer;

float CircleRadiusF;
int TexResolution;
int PointsCount;
int Radius;
int RadiusSqr;
float4 ClearColor;
float4 CircleColor;
float Time;

float4 getCirclePixel(int x, int y)
{
    return float4(abs(x) / CircleRadiusF, abs(y) / CircleRadiusF, 1.0, 1.0);
}

void plot1(int x, int y, int2 c, float4 color)
{
    uint2 xy = uint2(c.x + x, c.y + y);
    if (Result[xy].w == 0)
    {
        Result[xy] = color;
    }
}

void plot8(int x, int y, int2 center, float4 color)
{
    plot1(x, y, center, color);
    plot1(y, x, center, color);
    plot1(x, -y, center, color);
    plot1(y, -x, center, color);
    plot1(-x, -y, center, color);
    plot1(-y, -x, center, color);
    plot1(-x, y, center, color);
    plot1(-y, x, center, color);
}

void drawMidpointCircle(int2 c, int r)
{
    int x = r;
    int y = 0;
    int d = 1 - r;

    while (x >= y)
    {
        if (d < 0)
        {
            d += (y << 1) + 3;
        }
        else
        {
            d += ((y - x) << 1) + 5;
            x--;
        }
        
        plot8(x, y, c, getCirclePixel(y, x));

        y++;
    }
}

void drawJeskoCircle(int2 c, int r)
{
    int t1 = r >> 4;
    int x = r;
    int y = 0;
    
    while (x >= y)
    {
        plot8(x, y, c, getCirclePixel(y, x));
        
        y++;
        t1 += y;
        int t2 = t1 - x;
        if (t2 >= 0)
        {
            t1 = t2;
            x--;
        }
    }
}

void drawHornCircle(int2 c, int r)
{
    int d = -r;
    int x = r;
    int y = 0;
    
    while (y <= x)
    {
        plot8(x, y, c, getCirclePixel(y, x));
        d += (y << 1) + 1;
        y++;
        if (d > 0)
        {
            d += -(x << 1) + 2;
            x--;
        }
    }
    
}

void drawDiamond(int2 c, int r)
{
    int x = r;
    int y = 0;
    
    while (x >= y)
    {
        plot8(x, y, c, CircleColor);
        
        y++;
        x--;
    }
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Points(uint3 id : SV_DispatchThreadID)
{
    PointsBuffer[id.x] = (int2)(random2(id.x + Time) * TexResolution);
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Circles(uint3 id : SV_DispatchThreadID)
{
    //drawJeskoCircle(PointsBuffer[id.x], Radius);
    drawMidpointCircle(PointsBuffer[id.x], Radius);
    drawHornCircle(PointsBuffer[id.x], Radius);
}

[numthreads(CIRCLE_THREADS, 1, 1)]
void Diamonds(uint3 id : SV_DispatchThreadID)
{
    drawDiamond(PointsBuffer[id.x], Radius);
}

[numthreads(31, 31, 1)]
void FillCircles(uint3 id : SV_DispatchThreadID)
{
    int2 center = int2(15, 15);
    int2 ray = (int2)id.xy - center;
    uint2 xy = PointsBuffer[id.z] + ray;
    
    if (Result[xy].w == 0.0 && dot(ray, ray) < RadiusSqr)
    {
        Result[xy] = getCirclePixel(ray.x, ray.y);
    }
}

[numthreads(1, 1, 1)]
void Line(uint3 id : SV_DispatchThreadID)
{
    drawLine(Result, PointsBuffer[0], PointsBuffer[1], 1);
}

[numthreads(CLEAR_THREADS, CLEAR_THREADS, 1)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = ClearColor;
}
